<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ä¹˜æ³•å­¦ä¹ æ¶ˆæ¶ˆä¹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 5px;
            margin: 0;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }

        .game-container {
            background: white;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: auto;
            max-height: 98vh;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 5px;
            font-size: 16px;
        }

        .score-board {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 5px;
            padding: 15px 20px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 6px;
            color: white;
            gap: 15px;
        }

        .score-item {
            text-align: center;
        }

        .score-label {
            font-size: 20px;
            opacity: 0.9;
        }

        .score-value {
            font-size: 28px;
            font-weight: bold;
            margin-top: 5px;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(18, 40px);
            gap: 2px;
            margin-bottom: 5px;
            background: #f0f0f0;
            padding: 4px;
            border-radius: 6px;
            flex-shrink: 0;
            width: fit-content;
            max-width: 100%;
        }

        .block {
            width: 40px;
            height: 40px;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 26px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            position: relative;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            will-change: transform;
        }

        .block:active {
            transform: scale(0.92);
            transition: transform 0.1s ease;
        }

        @media (hover: hover) and (pointer: fine) {
            .block:hover {
                transform: scale(1.05);
            }
        }

        .block.selected {
            transform: scale(0.95);
            box-shadow: 0 0 0 3px #FFD700, inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        /* è¿çº¿æ•ˆæœ */
        .selection-line {
            position: absolute;
            background: rgba(255, 215, 0, 0.6);
            height: 6px;
            transform-origin: left center;
            pointer-events: none;
            z-index: 10;
            border-radius: 3px;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        .game-board {
            position: relative;
        }

        .block.shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: scale(0);
            }
        }

        .question-area {
            background: #fff9e6;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 0;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            border: 2px solid #ffd700;
            flex-shrink: 0;
        }

        .question-text {
            font-size: 18px;
            text-align: center;
            color: #333;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .answers {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .answer-btn {
            padding: 6px;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid #667eea;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }

        .answer-btn:active {
            transform: scale(0.95);
            transition: transform 0.1s ease;
        }

        @media (hover: hover) and (pointer: fine) {
            .answer-btn:hover {
                background: #667eea;
                color: white;
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
            }
        }

        .answer-btn.correct {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        .answer-btn.wrong {
            background: #f44336;
            color: white;
            border-color: #f44336;
            animation: shake 0.5s;
        }

        .empty-question {
            text-align: center;
            color: #999;
            font-size: 12px;
        }

        .game-over {
            text-align: center;
            padding: 40px;
        }

        .game-over h2 {
            color: #667eea;
            font-size: 32px;
            margin-bottom: 20px;
        }

        .restart-btn {
            padding: 15px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }

        .restart-btn-small {
            padding: 8px 20px;
            font-size: 14px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: 2px solid white;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .restart-btn:active {
            transform: scale(0.95);
        }

        @media (hover: hover) and (pointer: fine) {
            .restart-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
            }
        }

        .restart-btn-small:active {
            transform: scale(0.92);
        }

        @media (hover: hover) and (pointer: fine) {
            .restart-btn-small:hover {
                background: white;
                color: #f5576c;
                transform: translateY(-2px);
                box-shadow: 0 3px 10px rgba(255, 255, 255, 0.4);
            }
        }

        /* å½¢çŠ¶æ ·å¼ */
        .shape-circle {
            border-radius: 50%;
        }

        .shape-square {
            border-radius: 3px;
        }

        .shape-diamond {
            border-radius: 3px;
            transform: rotate(45deg);
        }

        .shape-diamond .block-content {
            transform: rotate(-45deg);
        }

        .block-content {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* å…¨å±æŒ‰é’® */
        .fullscreen-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(102, 126, 234, 0.9);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .fullscreen-btn:active {
            transform: scale(0.9);
        }

        /* è¿”å›é¦–é¡µæŒ‰é’® */
        .home-btn {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 10px 20px;
            background: rgba(102, 126, 234, 0.9);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .home-btn:active {
            transform: scale(0.95);
        }

        @media (hover: hover) and (pointer: fine) {
            .home-btn:hover {
                background: rgba(102, 126, 234, 1);
                transform: translateY(-2px);
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            }
        }

        /* æ¨ªç«–å±æç¤º */
        .orientation-tip {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            z-index: 9999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-size: 24px;
            text-align: center;
            padding: 20px;
        }

        .orientation-tip .icon {
            font-size: 80px;
            margin-bottom: 20px;
        }

        @media screen and (orientation: portrait) and (max-width: 768px) {
            .orientation-tip.show-portrait-tip {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <!-- è¿”å›é¦–é¡µæŒ‰é’® -->
    <a href="index.html" class="home-btn" title="è¿”å›é¦–é¡µ">
        <span>ğŸ </span>
        <span>é¦–é¡µ</span>
    </a>
    
    <!-- å…¨å±æŒ‰é’® -->
    <button class="fullscreen-btn" id="fullscreenBtn" title="å…¨å±">â›¶</button>
    
    <!-- æ¨ªç«–å±æç¤º -->
    <div class="orientation-tip" id="orientationTip">
        <div class="icon">ğŸ“±â†’ğŸ”„</div>
        <div>ä¸ºäº†æ›´å¥½çš„æ¸¸æˆä½“éªŒ<br>è¯·å°†è®¾å¤‡æ¨ªå‘æ”¾ç½®</div>
    </div>
    
    <div class="game-container">
        <h1>ğŸ® ä¹˜æ³•å­¦ä¹ æ¶ˆæ¶ˆä¹</h1>
        
        <div class="score-board">
            <div class="score-item">
                <div class="score-label">å¾—åˆ†</div>
                <div class="score-value" id="score">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">è¿å‡»</div>
                <div class="score-value" id="combo">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">æ­£ç¡®ç‡</div>
                <div class="score-value" id="accuracy">100%</div>
            </div>
            <button class="restart-btn-small" id="restartBtn" title="é‡æ–°å¼€å§‹">ğŸ”„ é‡æ–°å¼€å§‹</button>
        </div>

        <div class="game-board" id="gameBoard"></div>

        <div class="question-area" id="questionArea">
            <div class="empty-question">
                é€‰æ‹©ç›¸é‚»çš„ç›¸åŒæ•°å­—è‰²å—å¼€å§‹æ¸¸æˆï¼
            </div>
        </div>
    </div>

    <script>
        class MultiplicationGame {
            constructor() {
                this.boardRows = 9;
                this.boardCols = 18;
                this.board = [];
                this.selectedBlocks = [];
                this.score = 0;
                this.combo = 0;
                this.correctAnswers = 0;
                this.totalAnswers = 0;
                this.currentQuestion = null;
                this.answerLocked = false;
                
                // è§¦æ‘¸æ»‘åŠ¨é€‰æ‹©ç›¸å…³
                this.isDrawing = false;
                this.lastTouchedBlock = null;
                this.selectionLines = [];
                
                // åˆå§‹åŒ–éŸ³æ•ˆç³»ç»Ÿ
                this.initAudio();
                
                // æ•°å­—å¯¹åº”çš„é¢œè‰²å’Œå½¢çŠ¶ - ä¼˜åŒ–ä¸ºé«˜é¥±å’Œåº¦ã€é«˜å¯¹æ¯”åº¦çš„é²œè‰³è‰²å½©
                this.blockStyles = {
                    1: { color: '#FF1744', shape: 'circle' },      // é²œè‰³çº¢è‰²
                    2: { color: '#00E676', shape: 'square' },      // é²œè‰³ç»¿è‰²
                    3: { color: '#2979FF', shape: 'diamond' },     // é²œè‰³è“è‰²
                    4: { color: '#FF9100', shape: 'circle' },      // é²œè‰³æ©™è‰²
                    5: { color: '#E040FB', shape: 'square' },      // é²œè‰³ç´«è‰²
                    6: { color: '#FFEA00', shape: 'diamond' },     // é²œè‰³é»„è‰²
                    7: { color: '#00E5FF', shape: 'circle' },      // é²œè‰³é’è‰²
                    8: { color: '#FF4081', shape: 'square' },      // é²œè‰³ç²‰è‰²
                    9: { color: '#76FF03', shape: 'diamond' }      // é²œè‰³é»„ç»¿è‰²
                };

                this.init();
                this.initFullscreen();
                this.initOrientationDetection();
                this.initRestartButton();
            }

            initFullscreen() {
                const fullscreenBtn = document.getElementById('fullscreenBtn');
                if (!fullscreenBtn) return;

                fullscreenBtn.addEventListener('click', () => {
                    const elem = document.documentElement;
                    if (!document.fullscreenElement) {
                        if (elem.requestFullscreen) {
                            elem.requestFullscreen();
                        } else if (elem.webkitRequestFullscreen) {
                            elem.webkitRequestFullscreen();
                        } else if (elem.msRequestFullscreen) {
                            elem.msRequestFullscreen();
                        }
                        fullscreenBtn.textContent = 'â›¶';
                    } else {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        } else if (document.msExitFullscreen) {
                            document.msExitFullscreen();
                        }
                        fullscreenBtn.textContent = 'â›¶';
                    }
                });

                // è§¦æ‘¸äº‹ä»¶æ”¯æŒ
                fullscreenBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    fullscreenBtn.click();
                });
            }

            initOrientationDetection() {
                // æ£€æµ‹å±å¹•æ–¹å‘ - åªåœ¨å°å±å¹•è®¾å¤‡ä¸Šæç¤º
                const checkOrientation = () => {
                    const tip = document.getElementById('orientationTip');
                    if (!tip) return;
                    
                    const isPortrait = window.innerHeight > window.innerWidth;
                    const isSmallScreen = window.innerWidth < 768;
                    
                    if (isPortrait && isSmallScreen) {
                        tip.classList.add('show-portrait-tip');
                    } else {
                        tip.classList.remove('show-portrait-tip');
                    }
                };

                checkOrientation();
                window.addEventListener('orientationchange', checkOrientation);
                window.addEventListener('resize', checkOrientation);
            }

            initRestartButton() {
                const restartBtn = document.getElementById('restartBtn');
                if (!restartBtn) return;

                const handleRestart = () => {
                    // é‡ç½®æ‰€æœ‰æ¸¸æˆçŠ¶æ€
                    this.score = 0;
                    this.combo = 0;
                    this.correctAnswers = 0;
                    this.totalAnswers = 0;
                    this.selectedBlocks = [];
                    this.currentQuestion = null;
                    this.answerLocked = false;
                    this.isDrawing = false;
                    this.lastTouchedBlock = null;
                    
                    // æ¸…é™¤è¿çº¿
                    this.clearSelectionLines();
                    
                    // é‡æ–°åˆå§‹åŒ–æ¸¸æˆæ¿
                    this.initBoard();
                    this.renderBoard();
                    this.updateScore();
                    this.clearQuestionArea();
                };

                restartBtn.addEventListener('click', handleRestart);
                
                // è§¦æ‘¸äº‹ä»¶æ”¯æŒ
                restartBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleRestart();
                });
            }

            init() {
                this.initBoard();
                this.renderBoard();
                this.updateScore();
            }

            initAudio() {
                // å»¶è¿Ÿåˆ›å»º AudioContextï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’
                this.audioContext = null;
                this.audioInitialized = false;
                this.initAudioOnFirstInteraction();
            }

            initAudioOnFirstInteraction() {
                const unlockAudio = async () => {
                    if (!this.audioInitialized) {
                        try {
                            // åœ¨ç”¨æˆ·äº¤äº’æ—¶åˆ›å»º AudioContext
                            if (!this.audioContext) {
                                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            }
                            
                            // æ¢å¤ AudioContextï¼ˆiOS Safari éœ€è¦ï¼‰
                            if (this.audioContext.state === 'suspended') {
                                await this.audioContext.resume();
                            }
                            
                            // æ’­æ”¾ä¸€ä¸ªé™éŸ³éŸ³ç¬¦æ¥è§£é”éŸ³é¢‘ï¼ˆiOS æŠ€å·§ï¼‰
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            gainNode.gain.value = 0.001; // å‡ ä¹é™éŸ³
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            oscillator.start(0);
                            oscillator.stop(0.001);
                            
                            this.audioInitialized = true;
                            console.log('éŸ³é¢‘å·²è§£é”');
                        } catch (error) {
                            console.error('éŸ³é¢‘è§£é”å¤±è´¥:', error);
                        }
                    }
                };
                
                // ç›‘å¬å¤šç§ç”¨æˆ·äº¤äº’äº‹ä»¶æ¥è§£é”éŸ³é¢‘
                document.addEventListener('touchstart', unlockAudio, { once: true });
                document.addEventListener('touchend', unlockAudio, { once: true });
                document.addEventListener('click', unlockAudio, { once: true });
                
                // åœ¨æ¸¸æˆæ¿ä¸Šä¹Ÿç›‘å¬äº‹ä»¶ï¼ˆç¡®ä¿ä¸€å®šä¼šè§¦å‘ï¼‰
                const gameBoard = document.getElementById('gameBoard');
                if (gameBoard) {
                    gameBoard.addEventListener('touchstart', unlockAudio, { once: true });
                }
            }

            // æ’­æ”¾æ­£ç¡®ç­”æ¡ˆéŸ³æ•ˆ
            playCorrectSound() {
                if (!this.audioContext || !this.audioInitialized) return;
                
                try {
                    const ctx = this.audioContext;
                    const oscillator = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    
                    // ä¸Šå‡çš„éŸ³è°ƒåºåˆ— (C-E-G)
                    const now = ctx.currentTime;
                    oscillator.frequency.setValueAtTime(523.25, now); // C5
                    oscillator.frequency.setValueAtTime(659.25, now + 0.1); // E5
                    oscillator.frequency.setValueAtTime(783.99, now + 0.2); // G5
                    
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.6, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    
                    oscillator.start(now);
                    oscillator.stop(now + 0.4);
                } catch (error) {
                    console.error('æ’­æ”¾éŸ³æ•ˆå¤±è´¥:', error);
                }
            }

            // æ’­æ”¾é”™è¯¯ç­”æ¡ˆéŸ³æ•ˆ
            playWrongSound() {
                if (!this.audioContext || !this.audioInitialized) return;
                
                try {
                    const ctx = this.audioContext;
                    const oscillator = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    
                    // ä¸‹é™çš„éŸ³è°ƒ (ä½æ²‰çš„é”™è¯¯æç¤ºéŸ³)
                    const now = ctx.currentTime;
                    oscillator.frequency.setValueAtTime(300, now);
                    oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                    
                    oscillator.type = 'sawtooth';
                    
                    gainNode.gain.setValueAtTime(0.4, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    
                    oscillator.start(now);
                    oscillator.stop(now + 0.3);
                } catch (error) {
                    console.error('æ’­æ”¾éŸ³æ•ˆå¤±è´¥:', error);
                }
            }

            // æ’­æ”¾æ¶ˆé™¤æ–¹å—éŸ³æ•ˆ
            playEliminateSound() {
                if (!this.audioContext || !this.audioInitialized) return;
                
                try {
                    const ctx = this.audioContext;
                    const oscillator = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    
                    // æ¸…è„†çš„æ¶ˆé™¤éŸ³æ•ˆ
                    const now = ctx.currentTime;
                    oscillator.frequency.setValueAtTime(1000, now);
                    oscillator.frequency.exponentialRampToValueAtTime(2000, now + 0.15);
                    
                    oscillator.type = 'square';
                    
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    
                    oscillator.start(now);
                    oscillator.stop(now + 0.15);
                } catch (error) {
                    console.error('æ’­æ”¾éŸ³æ•ˆå¤±è´¥:', error);
                }
            }

            // æ’­æ”¾é€‰ä¸­è‰²å—éŸ³æ•ˆ
            playSelectSound() {
                if (!this.audioContext || !this.audioInitialized) return;
                
                try {
                    const ctx = this.audioContext;
                    const oscillator = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    
                    // æ¸…è„†çš„ç‚¹å‡»éŸ³æ•ˆ - çŸ­ä¿ƒæ˜å¿«
                    const now = ctx.currentTime;
                    oscillator.frequency.setValueAtTime(800, now);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
                    
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.25, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                    
                    oscillator.start(now);
                    oscillator.stop(now + 0.08);
                } catch (error) {
                    console.error('æ’­æ”¾éŸ³æ•ˆå¤±è´¥:', error);
                }
            }

            initBoard() {
                // å…ˆç”¨éšæœºæ•°å¡«å……æ•´ä¸ªæ£‹ç›˜
                this.board = [];
                for (let row = 0; row < this.boardRows; row++) {
                    this.board[row] = [];
                    for (let col = 0; col < this.boardCols; col++) {
                        this.board[row][col] = this.getRandomNumber();
                    }
                }
                
                // åˆ›å»ºèšç±»åŒºåŸŸï¼Œè®©ç›¸åŒæ•°å­—å½¢æˆè¿ç»­çš„ç¾¤ç»„
                this.createClusters();
            }

            getRandomNumber() {
                return Math.floor(Math.random() * 9) + 1;
            }

            // åˆ›å»ºæ•°å­—èšç±»ï¼Œè®©ç›¸åŒæ•°å­—å½¢æˆ2-9ä¸ªè¿ç»­ç›¸é‚»çš„åŒºåŸŸ
            createClusters() {
                // éšæœºç”Ÿæˆ20-30ä¸ªèšç±»ä¸­å¿ƒï¼ˆå¢åŠ æ•°é‡ä»¥é€‚åº”æ›´å¤§çš„æ£‹ç›˜ï¼‰
                const clusterCount = 20 + Math.floor(Math.random() * 11);
                
                for (let i = 0; i < clusterCount; i++) {
                    // éšæœºé€‰æ‹©ä¸€ä¸ªèµ·å§‹ä½ç½®
                    const startRow = Math.floor(Math.random() * this.boardRows);
                    const startCol = Math.floor(Math.random() * this.boardCols);
                    const clusterValue = this.getRandomNumber();
                    
                    // éšæœºå†³å®šèšç±»å¤§å° (2-9ä¸ªæ–¹å—)
                    const clusterSize = 2 + Math.floor(Math.random() * 8);
                    
                    // ä»èµ·å§‹ä½ç½®æ‰©å±•èšç±»
                    this.expandCluster(startRow, startCol, clusterValue, clusterSize);
                }
            }

            // ä»æŒ‡å®šä½ç½®æ‰©å±•èšç±»
            expandCluster(startRow, startCol, value, targetSize) {
                // é¦–å…ˆæ£€æŸ¥èµ·å§‹ä½ç½®å‘¨å›´çš„è¿é€šåŒºåŸŸå¤§å°
                const existingConnectedSize = this.getConnectedRegionSize(startRow, startCol, value);
                
                // å¦‚æœå·²ç»å­˜åœ¨çš„è¿é€šåŒºåŸŸ + ç›®æ ‡å¤§å°ä¼šè¶…è¿‡9ï¼Œåˆ™è°ƒæ•´ç›®æ ‡å¤§å°
                const adjustedTargetSize = Math.min(targetSize, 9 - existingConnectedSize);
                
                if (adjustedTargetSize <= 0) {
                    // å·²ç»æœ‰è¶³å¤Ÿå¤§çš„åŒºåŸŸï¼Œä¸å†æ‰©å±•
                    return;
                }
                
                const cluster = [{row: startRow, col: startCol}];
                this.board[startRow][startCol] = value;
                
                // ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢æ‰©å±•èšç±»
                while (cluster.length < adjustedTargetSize) {
                    // ä»ç°æœ‰èšç±»ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªæ–¹å—
                    const current = cluster[Math.floor(Math.random() * cluster.length)];
                    
                    // è·å–ç›¸é‚»çš„å¯ç”¨ä½ç½®ï¼ˆè¦æ£€æŸ¥ä¸ä¼šå¯¼è‡´è¶…è¿‡9ä¸ªè¿ç»­ï¼‰
                    const neighbors = this.getSafeNeighbors(current.row, current.col, cluster, value);
                    
                    if (neighbors.length === 0) {
                        // æ²¡æœ‰å¯ç”¨çš„ç›¸é‚»ä½ç½®ï¼Œåœæ­¢æ‰©å±•
                        break;
                    }
                    
                    // éšæœºé€‰æ‹©ä¸€ä¸ªç›¸é‚»ä½ç½®
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    this.board[next.row][next.col] = value;
                    cluster.push(next);
                }
            }

            // è·å–å®‰å…¨çš„ç›¸é‚»ä½ç½®ï¼ˆä¸ä¼šå¯¼è‡´è¶…è¿‡9ä¸ªè¿ç»­æ–¹å—ï¼‰
            getSafeNeighbors(row, col, existingCluster, value) {
                const neighbors = [];
                const directions = [
                    {dr: -1, dc: 0},  // ä¸Š
                    {dr: 1, dc: 0},   // ä¸‹
                    {dr: 0, dc: -1},  // å·¦
                    {dr: 0, dc: 1}    // å³
                ];
                
                for (const dir of directions) {
                    const newRow = row + dir.dr;
                    const newCol = col + dir.dc;
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨æ£‹ç›˜èŒƒå›´å†…
                    if (newRow >= 0 && newRow < this.boardRows && 
                        newCol >= 0 && newCol < this.boardCols) {
                        
                        // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨èšç±»ä¸­
                        const alreadyInCluster = existingCluster.some(
                            pos => pos.row === newRow && pos.col === newCol
                        );
                        
                        if (!alreadyInCluster) {
                            // ä¸´æ—¶è®¾ç½®è¯¥ä½ç½®ä¸ºç›®æ ‡å€¼ï¼Œæ£€æŸ¥è¿é€šåŒºåŸŸå¤§å°
                            const originalValue = this.board[newRow][newCol];
                            this.board[newRow][newCol] = value;
                            
                            const connectedSize = this.getConnectedRegionSize(newRow, newCol, value);
                            
                            // æ¢å¤åŸå€¼
                            this.board[newRow][newCol] = originalValue;
                            
                            // åªæœ‰å½“è¿é€šåŒºåŸŸä¸è¶…è¿‡9æ—¶æ‰æ·»åŠ 
                            if (connectedSize <= 9) {
                                neighbors.push({row: newRow, col: newCol});
                            }
                        }
                    }
                }
                
                return neighbors;
            }

            // è·å–ä»æŒ‡å®šä½ç½®å¼€å§‹çš„ç›¸åŒå€¼çš„è¿é€šåŒºåŸŸå¤§å°
            getConnectedRegionSize(startRow, startCol, value) {
                const visited = new Set();
                const queue = [{row: startRow, col: startCol}];
                visited.add(`${startRow},${startCol}`);
                
                let count = 0;
                
                while (queue.length > 0) {
                    const {row, col} = queue.shift();
                    
                    // æ£€æŸ¥å½“å‰ä½ç½®çš„å€¼
                    if (this.board[row][col] === value) {
                        count++;
                        
                        // æ£€æŸ¥å››ä¸ªæ–¹å‘
                        const directions = [
                            {dr: -1, dc: 0},
                            {dr: 1, dc: 0},
                            {dr: 0, dc: -1},
                            {dr: 0, dc: 1}
                        ];
                        
                        for (const dir of directions) {
                            const newRow = row + dir.dr;
                            const newCol = col + dir.dc;
                            const key = `${newRow},${newCol}`;
                            
                            if (newRow >= 0 && newRow < this.boardRows &&
                                newCol >= 0 && newCol < this.boardCols &&
                                !visited.has(key)) {
                                
                                visited.add(key);
                                queue.push({row: newRow, col: newCol});
                            }
                        }
                    }
                }
                
                return count;
            }

            renderBoard() {
                const gameBoard = document.getElementById('gameBoard');
                gameBoard.innerHTML = '';

                for (let row = 0; row < this.boardRows; row++) {
                    for (let col = 0; col < this.boardCols; col++) {
                        const value = this.board[row][col];
                        if (value !== null) {
                            const block = this.createBlock(value, row, col);
                            gameBoard.appendChild(block);
                        } else {
                            const emptyBlock = document.createElement('div');
                            gameBoard.appendChild(emptyBlock);
                        }
                    }
                }
            }

            createBlock(value, row, col) {
                const block = document.createElement('div');
                const style = this.blockStyles[value];
                
                block.className = `block shape-${style.shape}`;
                block.style.backgroundColor = style.color;
                block.dataset.row = row;
                block.dataset.col = col;
                block.dataset.value = value;

                const content = document.createElement('div');
                content.className = 'block-content';
                content.textContent = value;
                block.appendChild(content);

                // é¼ æ ‡ç‚¹å‡»äº‹ä»¶ï¼ˆæ¡Œé¢ç«¯ï¼‰
                block.addEventListener('click', () => this.handleBlockClick(row, col));
                
                // è§¦æ‘¸äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯ï¼‰- æ”¯æŒåˆ’çº¿é€‰æ‹©
                block.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleTouchStart(row, col, e);
                });
                
                block.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleTouchMove(e);
                });
                
                block.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleTouchEnd();
                });
                
                block.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.handleTouchEnd();
                });

                return block;
            }

            handleBlockClick(row, col) {
                const value = this.board[row][col];
                if (value === null) return;

                // å¦‚æœå·²ç»ç­”é¢˜é”å®šï¼Œä¸å…è®¸é€‰æ‹©
                if (this.answerLocked) return;

                const blockKey = `${row},${col}`;

                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»å·²é€‰ä¸­çš„æ–¹å—
                const existingIndex = this.selectedBlocks.findIndex(b => b.key === blockKey);
                
                if (existingIndex !== -1) {
                    // ç¬¬äºŒæ¬¡ç‚¹å‡»åŒä¸€æ–¹å—ï¼Œå–æ¶ˆé€‰æ‹©
                    this.clearSelection();
                    return;
                }

                // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªé€‰æ‹©çš„æ–¹å—
                if (this.selectedBlocks.length === 0) {
                    this.selectedBlocks.push({ row, col, value, key: blockKey });
                    this.playSelectSound(); // æ’­æ”¾é€‰ä¸­éŸ³æ•ˆ
                    this.updateBlockSelection();
                } else {
                    const firstBlock = this.selectedBlocks[0];
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸ºç›¸åŒæ•°å­—
                    if (value !== firstBlock.value) {
                        // ç‚¹å‡»ä¸åŒæ•°å­—ï¼Œæ¸…ç©ºé‡é€‰
                        this.clearSelection();
                        this.selectedBlocks.push({ row, col, value, key: blockKey });
                        this.playSelectSound(); // æ’­æ”¾é€‰ä¸­éŸ³æ•ˆ
                        this.updateBlockSelection();
                        return;
                    }

                    // æ£€æŸ¥æ˜¯å¦ä¸ä»»æ„ä¸€ä¸ªå·²é€‰ä¸­çš„æ–¹å—ç›¸é‚»
                    const isAdjacentToAny = this.selectedBlocks.some(selectedBlock => 
                        this.isAdjacent(selectedBlock, { row, col })
                    );
                    
                    if (!isAdjacentToAny) {
                        // ä¸ç›¸é‚»ï¼Œæ˜¾ç¤ºé”™è¯¯æç¤º
                        this.showError(row, col);
                        return;
                    }

                    // æ·»åŠ åˆ°é€‰ä¸­åˆ—è¡¨
                    this.selectedBlocks.push({ row, col, value, key: blockKey });
                    this.playSelectSound(); // æ’­æ”¾é€‰ä¸­éŸ³æ•ˆ
                    this.updateBlockSelection();
                }

                // å¦‚æœé€‰ä¸­äº†2ä¸ªæˆ–ä»¥ä¸Šï¼Œæ›´æ–°é¢˜ç›®
                if (this.selectedBlocks.length >= 2) {
                    this.updateQuestion();
                }
            }

            isAdjacent(block1, block2) {
                const rowDiff = Math.abs(block1.row - block2.row);
                const colDiff = Math.abs(block1.col - block2.col);
                return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
            }

            showError(row, col) {
                const blocks = document.querySelectorAll('.block');
                blocks.forEach(block => {
                    if (block.dataset.row == row && block.dataset.col == col) {
                        block.classList.add('shake');
                        setTimeout(() => block.classList.remove('shake'), 500);
                    }
                });
            }

            updateBlockSelection() {
                const blocks = document.querySelectorAll('.block');
                blocks.forEach(block => {
                    const key = `${block.dataset.row},${block.dataset.col}`;
                    if (this.selectedBlocks.some(b => b.key === key)) {
                        block.classList.add('selected');
                    } else {
                        block.classList.remove('selected');
                    }
                });
            }

            clearSelection() {
                this.selectedBlocks = [];
                this.currentQuestion = null;
                this.answerLocked = false;
                this.isDrawing = false;
                this.lastTouchedBlock = null;
                this.updateBlockSelection();
                this.clearQuestionArea();
                this.clearSelectionLines();
            }

            // è§¦æ‘¸å¼€å§‹ - å¼€å§‹åˆ’çº¿é€‰æ‹©
            handleTouchStart(row, col, e) {
                const value = this.board[row][col];
                if (value === null || this.answerLocked) return;

                // å¼€å§‹æ–°çš„é€‰æ‹©
                this.isDrawing = true;
                this.selectedBlocks = [];
                this.clearSelectionLines();
                
                const blockKey = `${row},${col}`;
                this.selectedBlocks.push({ row, col, value, key: blockKey });
                this.lastTouchedBlock = { row, col };
                this.playSelectSound();
                this.updateBlockSelection();
            }

            // è§¦æ‘¸ç§»åŠ¨ - è¿ç»­é€‰æ‹©
            handleTouchMove(e) {
                if (!this.isDrawing || this.answerLocked) return;

                const touch = e.touches[0];
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                
                if (!element || !element.classList.contains('block')) return;

                const row = parseInt(element.dataset.row);
                const col = parseInt(element.dataset.col);
                const value = this.board[row][col];
                
                if (value === null) return;

                // æ£€æŸ¥æ˜¯å¦æ˜¯åŒä¸€ä¸ªæ–¹å—
                if (this.lastTouchedBlock && 
                    this.lastTouchedBlock.row === row && 
                    this.lastTouchedBlock.col === col) {
                    return;
                }

                const blockKey = `${row},${col}`;
                const existingIndex = this.selectedBlocks.findIndex(b => b.key === blockKey);
                
                // å¦‚æœå·²ç»é€‰ä¸­ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯å›é€€æ“ä½œ
                if (existingIndex !== -1) {
                    // å¦‚æœè§¦æ‘¸çš„æ˜¯å€’æ•°ç¬¬äºŒä¸ªæ–¹å—ï¼Œè¯´æ˜æ˜¯åœ¨å›é€€
                    if (existingIndex === this.selectedBlocks.length - 2) {
                        this.selectedBlocks.pop();
                        this.lastTouchedBlock = { row, col };
                        this.updateBlockSelection();
                        this.updateSelectionLines();
                    }
                    return;
                }

                const firstBlock = this.selectedBlocks[0];
                
                // æ£€æŸ¥æ•°å­—æ˜¯å¦ç›¸åŒ
                if (value !== firstBlock.value) {
                    return;
                }

                // æ£€æŸ¥æ˜¯å¦ä¸ä¸Šä¸€ä¸ªé€‰ä¸­çš„æ–¹å—ç›¸é‚»
                if (!this.isAdjacent(this.lastTouchedBlock, { row, col })) {
                    return;
                }

                // æ·»åŠ åˆ°é€‰ä¸­åˆ—è¡¨
                this.selectedBlocks.push({ row, col, value, key: blockKey });
                this.lastTouchedBlock = { row, col };
                this.playSelectSound();
                this.updateBlockSelection();
                this.updateSelectionLines();

                // æ›´æ–°é¢˜ç›®
                if (this.selectedBlocks.length >= 2) {
                    this.updateQuestion();
                }
            }

            // è§¦æ‘¸ç»“æŸ
            handleTouchEnd() {
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                
                // å¦‚æœé€‰ä¸­çš„æ–¹å—å°‘äº2ä¸ªï¼Œæ¸…é™¤é€‰æ‹©
                if (this.selectedBlocks.length < 2) {
                    this.clearSelection();
                } else {
                    // ä¿æŒé€‰æ‹©çŠ¶æ€ï¼Œç­‰å¾…ç­”é¢˜
                    this.updateQuestion();
                }
            }

            // ç»˜åˆ¶é€‰æ‹©è¿çº¿
            updateSelectionLines() {
                this.clearSelectionLines();
                
                if (this.selectedBlocks.length < 2) return;

                const gameBoard = document.getElementById('gameBoard');
                const boardRect = gameBoard.getBoundingClientRect();

                for (let i = 0; i < this.selectedBlocks.length - 1; i++) {
                    const block1 = this.selectedBlocks[i];
                    const block2 = this.selectedBlocks[i + 1];
                    
                    const element1 = document.querySelector(`[data-row="${block1.row}"][data-col="${block1.col}"]`);
                    const element2 = document.querySelector(`[data-row="${block2.row}"][data-col="${block2.col}"]`);
                    
                    if (!element1 || !element2) continue;

                    const rect1 = element1.getBoundingClientRect();
                    const rect2 = element2.getBoundingClientRect();

                    const x1 = rect1.left + rect1.width / 2 - boardRect.left;
                    const y1 = rect1.top + rect1.height / 2 - boardRect.top;
                    const x2 = rect2.left + rect2.width / 2 - boardRect.left;
                    const y2 = rect2.top + rect2.height / 2 - boardRect.top;

                    const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

                    const line = document.createElement('div');
                    line.className = 'selection-line';
                    line.style.width = `${length}px`;
                    line.style.left = `${x1}px`;
                    line.style.top = `${y1}px`;
                    line.style.transform = `rotate(${angle}deg)`;

                    gameBoard.appendChild(line);
                    this.selectionLines.push(line);
                }
            }

            // æ¸…é™¤é€‰æ‹©è¿çº¿
            clearSelectionLines() {
                this.selectionLines.forEach(line => {
                    if (line.parentNode) {
                        line.parentNode.removeChild(line);
                    }
                });
                this.selectionLines = [];
            }

            updateQuestion() {
                const count = this.selectedBlocks.length;
                const number = this.selectedBlocks[0].value;
                const correctAnswer = count * number;

                // ç”Ÿæˆä¸¤ä¸ªé”™è¯¯ç­”æ¡ˆ
                const wrongAnswers = this.generateWrongAnswers(correctAnswer);
                const allAnswers = [correctAnswer, ...wrongAnswers];
                
                // ä½¿ç”¨Fisher-Yatesæ´—ç‰Œç®—æ³•éšæœºæ‰“ä¹±ç­”æ¡ˆé¡ºåº
                this.shuffleArray(allAnswers);

                this.currentQuestion = {
                    count,
                    number,
                    correctAnswer,
                    answers: allAnswers
                };

                this.renderQuestion();
            }

            // Fisher-Yatesæ´—ç‰Œç®—æ³•
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            generateWrongAnswers(correct) {
                const wrong = new Set();
                while (wrong.size < 2) {
                    const offset = Math.floor(Math.random() * 10) - 5;
                    if (offset !== 0) {
                        const wrongAnswer = correct + offset;
                        if (wrongAnswer > 0 && wrongAnswer !== correct) {
                            wrong.add(wrongAnswer);
                        }
                    }
                }
                return Array.from(wrong);
            }

            renderQuestion() {
                const questionArea = document.getElementById('questionArea');
                const { count, number, answers } = this.currentQuestion;

                questionArea.innerHTML = `
                    <div class="question-text">${count} Ã— ${number} = ?</div>
                    <div class="answers">
                        ${answers.map(ans => `
                            <button class="answer-btn" onclick="game.checkAnswer(${ans})">${ans}</button>
                        `).join('')}
                    </div>
                `;
                
                // ä¸ºç­”æ¡ˆæŒ‰é’®æ·»åŠ è§¦æ‘¸äº‹ä»¶æ”¯æŒ
                const answerButtons = questionArea.querySelectorAll('.answer-btn');
                answerButtons.forEach(btn => {
                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        if (!btn.disabled) {
                            const answer = parseInt(btn.textContent);
                            this.checkAnswer(answer);
                        }
                    });
                });
            }

            clearQuestionArea() {
                const questionArea = document.getElementById('questionArea');
                questionArea.innerHTML = `
                    <div class="empty-question">
                        é€‰æ‹©ç›¸é‚»çš„ç›¸åŒæ•°å­—è‰²å—å¼€å§‹æ¸¸æˆï¼
                    </div>
                `;
            }

            checkAnswer(answer) {
                if (!this.currentQuestion || this.answerLocked) return;

                // é”å®šç­”é¢˜ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
                this.answerLocked = true;

                this.totalAnswers++;
                const isCorrect = answer === this.currentQuestion.correctAnswer;

                if (isCorrect) {
                    this.handleCorrectAnswer();
                } else {
                    this.handleWrongAnswer(answer);
                }
            }

            handleCorrectAnswer() {
                this.correctAnswers++;
                this.combo++;
                
                // æ’­æ”¾æ­£ç¡®éŸ³æ•ˆ
                this.playCorrectSound();
                
                // è®¡ç®—å¾—åˆ†
                const baseScore = this.selectedBlocks.length * 10;
                const comboBonus = this.combo * 5;
                this.score += baseScore + comboBonus;

                // æ˜¾ç¤ºæ­£ç¡®åé¦ˆ
                this.showAnswerFeedback(true);

                // æ¶ˆé™¤æ–¹å—
                setTimeout(() => {
                    this.eliminateBlocks();
                    this.updateScore();
                }, 500);
            }

            handleWrongAnswer(answer) {
                this.combo = 0;
                
                // æ’­æ”¾é”™è¯¯éŸ³æ•ˆ
                this.playWrongSound();
                
                // æ˜¾ç¤ºé”™è¯¯åé¦ˆ
                this.showAnswerFeedback(false);

                // æ¸…é™¤é€‰æ‹©
                setTimeout(() => {
                    this.clearSelection();
                    this.updateScore();
                }, 1000);
            }

            showAnswerFeedback(isCorrect) {
                const buttons = document.querySelectorAll('.answer-btn');
                buttons.forEach(btn => {
                    const btnAnswer = parseInt(btn.textContent);
                    if (isCorrect && btnAnswer === this.currentQuestion.correctAnswer) {
                        btn.classList.add('correct');
                    } else if (!isCorrect && btnAnswer === this.currentQuestion.correctAnswer) {
                        btn.classList.add('correct');
                    } else if (!isCorrect) {
                        btn.classList.add('wrong');
                    }
                    btn.disabled = true;
                });
            }

            eliminateBlocks() {
                // æ’­æ”¾æ¶ˆé™¤éŸ³æ•ˆ
                this.playEliminateSound();
                
                // æ¸…é™¤è¿çº¿
                this.clearSelectionLines();
                
                // æ·»åŠ æ¶ˆé™¤åŠ¨ç”»
                const blocks = document.querySelectorAll('.block.selected');
                blocks.forEach(block => {
                    block.style.animation = 'fadeOut 0.5s forwards';
                });

                // æ›´æ–°boardæ•°ç»„
                setTimeout(() => {
                    this.selectedBlocks.forEach(({ row, col }) => {
                        this.board[row][col] = null;
                    });

                    // æ–¹å—ä¸‹è½
                    this.dropBlocks();
                    
                    // å¡«å……æ–°æ–¹å—
                    this.fillNewBlocks();
                    
                    // é‡æ–°æ¸²æŸ“
                    this.renderBoard();
                    
                    // æ¸…é™¤é€‰æ‹©
                    this.clearSelection();
                }, 500);
            }

            dropBlocks() {
                for (let col = 0; col < this.boardCols; col++) {
                    let emptyRow = this.boardRows - 1;
                    for (let row = this.boardRows - 1; row >= 0; row--) {
                        if (this.board[row][col] !== null) {
                            if (row !== emptyRow) {
                                this.board[emptyRow][col] = this.board[row][col];
                                this.board[row][col] = null;
                            }
                            emptyRow--;
                        }
                    }
                }
            }

            fillNewBlocks() {
                for (let row = 0; row < this.boardRows; row++) {
                    for (let col = 0; col < this.boardCols; col++) {
                        if (this.board[row][col] === null) {
                            this.board[row][col] = this.getRandomNumber();
                        }
                    }
                }
            }

            updateScore() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('combo').textContent = this.combo;
                
                const accuracy = this.totalAnswers === 0 
                    ? 100 
                    : Math.round((this.correctAnswers / this.totalAnswers) * 100);
                document.getElementById('accuracy').textContent = accuracy + '%';
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        const game = new MultiplicationGame();
    </script>
</body>
</html>